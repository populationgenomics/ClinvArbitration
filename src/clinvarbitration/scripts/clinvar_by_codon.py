"""
Method file for re-sorting clinvar annotations by codon

Takes a TSV of annotated Pathogenic Clinvar Variants
Fields: Transcript, Amino Acid Change, ClinVar Allele ID, ClinVar Gold Stars
- Transcript is the ENST ID
- Amino Acid Change is in the format [number][letter]>[number][letter], e.g. "334N>334T"
    we're only using SNVs, so the number should be the same
- ClinVar Allele ID and Gold Stars are both integers

This makes the assumption that the annotated data here
has been generated by summarise_clinvar_entries.py:

- SNV only
- Clinvar Pathogenic only
- ClinVar decision/alleles/gold stars are in INFO
"""

import re
import zoneinfo
from argparse import ArgumentParser
from collections import defaultdict
from datetime import datetime

import hail as hl
from loguru import logger

# I really want the linter to just tolerate naive datetimes, but it won't
TIMEZONE = zoneinfo.ZoneInfo('Australia/Brisbane')

# captures the number in amino_acid_changes, e.g. "334N>334T"
# there's the potential to not have the last AA if it's a nonsense
NUMBER_RE = re.compile(r'(\d+)\D>(\d+)\D?')

TSV_KEYS = ['transcript', 'codon', 'clinvar_alleles']


def cli_main():
    """
    alternative access point with CLI arguments
    """
    parser = ArgumentParser()
    parser.add_argument(
        '-i',
        help='Path to the TSV',
    )
    parser.add_argument(
        '-o',
        help='Root to export PM5 table and JSON to',
    )
    parser.add_argument(
        '--assembly',
        help='genome build to use',
        default='GRCh38',
        choices=['GRCh37', 'GRCh38'],
    )
    args = parser.parse_args()

    main(input_tsv=args.i, output_root=args.o, assembly=args.assembly)


def parse_tsv_into_dict(input_tsv: str) -> dict[str, set[str]]:
    """
    parse the TSV, and create the intermediate dictionary
    Args:
        input_tsv (str): path to an input TSV

    Returns:
        dictionary of results,
    """

    # create a dictionary to store the parsed entries
    clinvar_dict = defaultdict(set)

    # crack open a cold TSV, and have a sip
    with open(input_tsv) as tsv_reader:
        for row in tsv_reader:
            # transcript, amino acid change, clinvar allele id, clinvar gold stars
            tx, aa, aid, stars = row.rstrip().split('\t')

            # find the codon number
            match = NUMBER_RE.match(aa)

            if not match:
                raise ValueError(f'No codon found in {aa}')

            if match.group(1) != match.group(2):
                raise ValueError(f'Codon numbers do not match in {aa}')

            aa_number = match.group(1)

            # extract the clinvar data
            clinvar_key = f'{aid}::{stars}'

            # identify the transcript and codon number
            transcript_key = f'{tx}::{aa_number}'

            # record this clinvar entry as being associated with this transcript & codon
            clinvar_dict[transcript_key].add(clinvar_key)

    return clinvar_dict


def write_results_as_tsv(clinvar_dict: dict[str, set[str]], tsv_path: str) -> None:
    """
    Write the dictionary to a TSV. Columns:
    - Transcript
    - Codon Number
    - ClinVar Allele IDs (joined by a plus sign)
    """

    with open(tsv_path, 'w') as tsv_writer:
        # write the header
        tsv_writer.write('\t'.join(TSV_KEYS) + '\n')
        for key, value in clinvar_dict.items():
            transcript_id, codon_number = key.split('::')
            # join the alleles with a plus sign
            tsv_writer.write(f'{transcript_id}\t{codon_number}\t{"+".join(sorted(value))}\n')

    logger.info(f'TSV written to {tsv_path}')


def parse_tsv_into_hail_table(data: str, table_path: str) -> None:
    """Read the TSV into a HailTable."""

    # all elements are Strings, so no need to specify types
    ht = hl.import_table(paths=data)

    # newkey is a legacy column name, and represents Transcript::Codon
    ht = ht.transmute(newkey=ht.transcript + '::' + ht.codon)

    ht = ht.key_by(ht.newkey)

    # implant the creation date
    ht = ht.annotate_globals(
        creation_date=datetime.now(tz=TIMEZONE).strftime('%Y-%m-%d'),
    )

    # write out
    ht.write(f'{table_path}', overwrite=True)
    logger.info(f'Hail Table written to {table_path}')


def main(input_tsv: str, output_root: str, assembly: str):
    """
    parse the TSV, and create a re-indexed table

    Args:
        input_tsv (str): path to an input vcf
        output_root ():
        assembly (str): genome build to use
    """

    # start the local hail runtime
    hl.context.init_spark(master='local[*]')
    hl.default_reference(assembly)

    # parse the TSV into a dictionary
    clinvar_dict = parse_tsv_into_dict(input_tsv)

    # write collected results as a TSV
    tsv_path = f'{output_root}.tsv'
    write_results_as_tsv(clinvar_dict, tsv_path)

    # now read the same as a Hail Table
    table_path = f'{output_root}.ht'
    parse_tsv_into_hail_table(
        data=tsv_path,
        table_path=table_path,
    )


if __name__ == '__main__':
    cli_main()
