"""
Method file for re-sorting clinvar annotations by codon

Takes a TSV of annotated Pathogenic Clinvar Variants
Fields: Transcript, Amino Acid Change, ClinVar Allele ID, ClinVar Gold Stars
- Transcript is the ENST ID
- Amino Acid Change is in the format [number][letter]>[number][letter], e.g. "334N>334T"
    we're only using SNVs, so the number should be the same
- ClinVar Allele ID and Gold Stars are both integers

This makes the assumption that the annotated data here
has been generated by summarise_clinvar_entries.py:

- SNV only
- Clinvar Pathogenic only
- ClinVar decision/alleles/gold stars are in INFO
"""

import json
import logging
import re
import zoneinfo
from argparse import ArgumentParser
from datetime import datetime
from collections import defaultdict

import hail as hl


# I really want the linter to just tolerate naive datetimes, but it won't
TIMEZONE = zoneinfo.ZoneInfo('Australia/Brisbane')

# the schema to use for the Hail Table
HAIL_SCHEMA = 'struct{newkey:str,clinvar_alleles:str}'

# captures the number in amino_acid_changes, e.g. "334N>334T"
# there's the potential to not have the last AA if it's a nonsense
NUMBER_RE = re.compile(r'(\d+)\D>(\d+)\D?')


def cli_main():
    """
    alternative access point with CLI arguments
    """
    logging.basicConfig(level=logging.INFO)
    parser = ArgumentParser()
    parser.add_argument(
        '-i',
        help='Path to the TSV',
    )
    parser.add_argument(
        '-o',
        help='Root to export PM5 table and JSON to',
    )
    parser.add_argument(
        '--assembly',
        help='genome build to use',
        default='GRCh38',
        choices=['GRCh37', 'GRCh38'],
    )
    args = parser.parse_args()

    main(input_tsv=args.i, output_root=args.o, assembly=args.assembly)


def parse_tsv_into_dict(input_tsv: str) -> dict[str, set[str]]:
    """
    parse the TSV, and create the intermediate dictionary
    Args:
        input_tsv (str): path to an input TSV

    Returns:
        dictionary of results,
    """

    # create a dictionary to store the re-parsed entries
    clinvar_dict = defaultdict(set)

    # crack open a cold TSV, and have a sip
    with open(input_tsv) as tsv_reader:
        for row in tsv_reader:
            # transcript, amino acid change, clinvar allele id, clinvar gold stars
            tx, aa, aid, stars = row.rstrip().split('\t')

            # find the codon number
            match = NUMBER_RE.match(aa)

            if not match:
                raise ValueError(f'No codon found in {aa}')

            assert match.group(1) == match.group(2), f'Codon numbers do not match in {aa}'

            aa_number = match.group(1)

            # extract the clinvar data
            clinvar_key = f'{aid}::{stars}'

            # identify the transcript and codon number
            transcript_key = f'{tx}::{aa_number}'

            # record this clinvar entry as being associated with this transcript & codon
            clinvar_dict[transcript_key].add(clinvar_key)

    return clinvar_dict


def parse_dictionary_into_hail_table(clinvar_dict: dict[str, set[str]], output_root: str, assembly: str) -> None:
    """
    write the dictionary to a Hail Table

    Args:
        clinvar_dict ():
        output_root (str): path to write outputs to
        assembly (str): genome build to use
    """

    # save the dictionary locally
    json_out_path = f'{output_root}.json'
    with open(json_out_path, 'w') as f:
        for key, value in clinvar_dict.items():
            new_dict = {'newkey': key, 'clinvar_alleles': '+'.join(sorted(value))}
            f.write(f'{json.dumps(new_dict)}\n')

    logging.info(f'JSON written to {json_out_path}')

    # now set a schema to read that into a table... if you want hail
    schema = hl.dtype(HAIL_SCHEMA)

    # import the table, and transmute to top-level attributes
    ht = hl.import_table(json_out_path, no_header=True, types={'f0': schema})
    ht = ht.transmute(**ht.f0)
    ht = ht.key_by(ht.newkey)

    # implant the creation date
    ht = ht.annotate_globals(
        creation_date=datetime.now(tz=TIMEZONE).strftime('%Y-%m-%d'),
    )

    # write out
    ht.write(f'{output_root}.ht', overwrite=True)
    logging.info(f'Hail Table written to {output_root}.ht')


def main(input_tsv: str, output_root: str, assembly: str):
    """
    parse the TSV, and create a re-indexed table

    Args:
        input_tsv (str): path to an input vcf
        output_root ():
        assembly (str): genome build to use
    """

    # start the local hail runtime
    hl.context.init_spark(master='local[1]')
    hl.default_reference('GRCh38')

    # parse the TSV into a dictionary
    clinvar_dict = parse_tsv_into_dict(input_tsv)

    parse_dictionary_into_hail_table(
        clinvar_dict=clinvar_dict,
        output_root=output_root,
        assembly=assembly,
    )


if __name__ == '__main__':
    cli_main()
