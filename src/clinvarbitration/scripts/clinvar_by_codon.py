"""
Method file for re-sorting clinvar annotations by codon

Takes a TSV of annotated Pathogenic Clinvar Variants
Fields: Transcript, Amino Acid Change, ClinVar Allele ID, ClinVar Gold Stars
- Transcript is the ENST ID
- Amino Acid Change is in the format [number][letter]>[number][letter], e.g. "334N>334T"
    we're only using SNVs, so the number should be the same
- ClinVar Allele ID and Gold Stars are both integers

This makes the assumption that the annotated data here
has been generated by summarise_clinvar_entries.py:

- SNV only
- Clinvar Pathogenic only
- ClinVar decision/alleles/gold stars are in INFO
"""

import json
import logging
import re

from argparse import ArgumentParser
from collections import defaultdict

import hail as hl

# captures the number in amino_acid_changes, e.g. "334N>334T"
# there's the potential to not have the last AA if it's a nonsense
NUMBER_RE = re.compile(r'(\d+)\D>(\d+)\D?')


def cli_main():
    """
    alternative access point with CLI arguments
    """
    logging.basicConfig(level=logging.INFO)
    parser = ArgumentParser()
    parser.add_argument(
        '-i',
        help='Path to the TSV',
    )
    parser.add_argument(
        '-o',
        help='Root to export PM5 table and JSON to',
    )
    parser.add_argument(
        '--assembly',
        help='genome build to use',
        default='GRCh38',
        choices=['GRCh37', 'GRCh38'],
    )
    args = parser.parse_args()

    main(input_tsv=args.i, output_root=args.o, assembly=args.assembly)


def main(input_tsv: str, output_root: str, assembly: str):
    """
    parse the TSV, and create a re-indexed table

    Args:
        input_tsv (str): path to an input vcf
        output_root ():
        assembly (str): genome build to use
    """

    # create a dictionary to store the re-parsed entries
    clinvar_dict = defaultdict(set)

    # crack open a cold TSV, and have a sip
    with open(input_tsv) as tsv_reader:
        for row in tsv_reader:
            # transcript, amino acid change, clinvar allele id, clinvar gold stars
            tx, aa, aid, stars = row.rstrip().split('\t')

            # find the codon number
            match = NUMBER_RE.match(aa)

            if not match:
                raise ValueError(f'No codon found in {aa}')

            assert match.group(1) == match.group(2), f'Codon numbers do not match in {aa}'

            aa_number = match.group(1)

            # extract the clinvar data
            clinvar_key = f'{aid}::{stars}'

            # identify the transcript and codon number
            transcript_key = f'{tx}::{aa_number}'

            # record this clinvar entry as being associated with this transcript & codon
            clinvar_dict[transcript_key].add(clinvar_key)

    # save the dictionary locally
    json_out_path = f'{output_root}.json'
    with open(json_out_path, 'w') as f:
        for key, value in clinvar_dict.items():
            new_dict = {'newkey': key, 'clinvar_alleles': '+'.join(value)}
            f.write(f'{json.dumps(new_dict)}\n')

    logging.info(f'JSON written to {json_out_path}')

    # now set a schema to read that into a table... if you want hail
    schema = hl.dtype('struct{newkey:str,clinvar_alleles:str}')

    # start the local hail runtime
    hl.context.init_local(default_reference=assembly)

    # import the table, and transmute to top-level attributes
    ht = hl.import_table(json_out_path, no_header=True, types={'f0': schema})
    ht = ht.transmute(**ht.f0)
    ht = ht.key_by(ht.newkey)

    # write out
    ht.write(f'{output_root}.ht', overwrite=True)
    logging.info(f'Hail Table written to {output_root}.ht')


if __name__ == '__main__':
    cli_main()
